<!DOCTYPE html>
<html lang="fr-FR" class="no-js">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width">
	<link rel="profile" href="https://gmpg.org/xfn/11">
	<link rel="pingback" href="https://thomas-veillard.fr/xmlrpc.php">
	<!--[if lt IE 9]>
	<script src="https://thomas-veillard.fr/wp-content/themes/twentyfifteen/js/html5.js?ver=3.7.0"></script>
	<![endif]-->
	<script>(function(html){html.className = html.className.replace(/\bno-js\b/,'js')})(document.documentElement);</script>
<meta name="robots" content="index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1">

	<!-- This site is optimized with the Yoast SEO plugin v17.3 - https://yoast.com/wordpress/plugins/seo/ -->
	<title>3. La ligne de commande et les entrées / sorties - Thomas VEILLARD</title>
	<link rel="canonical" href="https://thomas-veillard.fr/theorie-des-systemes-dexploitation-et-pratique-de-gnu-linux/chapitre-2-les-interfaces-utilisateur/3-la-ligne-de-commande-et-les-entrees-sorties/">
	<meta property="og:locale" content="fr_FR">
	<meta property="og:type" content="article">
	<meta property="og:title" content="3. La ligne de commande et les entrées / sorties - Thomas VEILLARD">
	<meta property="og:description" content="Rappels Lors des précédentes séances, nous avons abordé : bash, un interpréteur de ligne de commande et un langage de script. coreutils, un ensemble de programmes en lignes de commande du projet GNU. apt, pour installer des logiciels, en ligne de commande à nouveau. L&rsquo;interpréteur de ligne de commande Bash est l’interpréteur le plus populaire &hellip; Continuer la lecture de 3. La ligne de commande et les entrées / sorties">
	<meta property="og:url" content="https://thomas-veillard.fr/theorie-des-systemes-dexploitation-et-pratique-de-gnu-linux/chapitre-2-les-interfaces-utilisateur/3-la-ligne-de-commande-et-les-entrees-sorties/">
	<meta property="og:site_name" content="Thomas VEILLARD">
	<meta property="article:published_time" content="2021-02-12T18:30:05+00:00">
	<meta property="article:modified_time" content="2021-02-14T12:46:07+00:00">
	<meta property="og:image" content="https://thomas-veillard.fr/wp-content/uploads/2021/01/ls-lhsa-etc.png">
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:label1" content="Écrit par">
	<meta name="twitter:data1" content="Thomas Veillard">
	<meta name="twitter:label2" content="Durée de lecture estimée">
	<meta name="twitter:data2" content="8 minutes">
	<script type="application/ld+json" class="yoast-schema-graph">{
	    "@context": "https://schema.org",
	    "@graph": [
	        {
	            "@type": "WebSite",
	            "@id": "https://thomas-veillard.fr/#website",
	            "url": "https://thomas-veillard.fr/",
	            "name": "Thomas VEILLARD",
	            "description": "Mes cours et supports pédagogiques pour l&#039;enseignement de l&#039;ingénierie informatique.",
	            "publisher": {
	                "@id": "https://thomas-veillard.fr/#/schema/person/98465ef1c45a4646324ef7c336388ffb"
	            },
	            "inLanguage": "fr-FR"
	        },
	        {
	            "@type": "ImageObject",
	            "@id": "https://thomas-veillard.fr/theorie-des-systemes-dexploitation-et-pratique-de-gnu-linux/chapitre-2-les-interfaces-utilisateur/3-la-ligne-de-commande-et-les-entrees-sorties/#primaryimage",
	            "inLanguage": "fr-FR",
	            "url": "https://thomas-veillard.fr/wp-content/uploads/2021/01/ls-lhsa-etc.png",
	            "contentUrl": "https://thomas-veillard.fr/wp-content/uploads/2021/01/ls-lhsa-etc.png",
	            "width": 768,
	            "height": 553
	        },
	        {
	            "@type": "WebPage",
	            "@id": "https://thomas-veillard.fr/theorie-des-systemes-dexploitation-et-pratique-de-gnu-linux/chapitre-2-les-interfaces-utilisateur/3-la-ligne-de-commande-et-les-entrees-sorties/#webpage",
	            "url": "https://thomas-veillard.fr/theorie-des-systemes-dexploitation-et-pratique-de-gnu-linux/chapitre-2-les-interfaces-utilisateur/3-la-ligne-de-commande-et-les-entrees-sorties/",
	            "name": "3. La ligne de commande et les entrées / sorties - Thomas VEILLARD",
	            "isPartOf": {
	                "@id": "https://thomas-veillard.fr/#website"
	            },
	            "primaryImageOfPage": {
	                "@id": "https://thomas-veillard.fr/theorie-des-systemes-dexploitation-et-pratique-de-gnu-linux/chapitre-2-les-interfaces-utilisateur/3-la-ligne-de-commande-et-les-entrees-sorties/#primaryimage"
	            },
	            "datePublished": "2021-02-12T18:30:05+00:00",
	            "dateModified": "2021-02-14T12:46:07+00:00",
	            "breadcrumb": {
	                "@id": "https://thomas-veillard.fr/theorie-des-systemes-dexploitation-et-pratique-de-gnu-linux/chapitre-2-les-interfaces-utilisateur/3-la-ligne-de-commande-et-les-entrees-sorties/#breadcrumb"
	            },
	            "inLanguage": "fr-FR",
	            "potentialAction": [
	                {
	                    "@type": "ReadAction",
	                    "target": [
	                        "https://thomas-veillard.fr/theorie-des-systemes-dexploitation-et-pratique-de-gnu-linux/chapitre-2-les-interfaces-utilisateur/3-la-ligne-de-commande-et-les-entrees-sorties/"
	                    ]
	                }
	            ]
	        },
	        {
	            "@type": "BreadcrumbList",
	            "@id": "https://thomas-veillard.fr/theorie-des-systemes-dexploitation-et-pratique-de-gnu-linux/chapitre-2-les-interfaces-utilisateur/3-la-ligne-de-commande-et-les-entrees-sorties/#breadcrumb",
	            "itemListElement": [
	                {
	                    "@type": "ListItem",
	                    "position": 1,
	                    "name": "Accueil",
	                    "item": "https://thomas-veillard.fr/"
	                },
	                {
	                    "@type": "ListItem",
	                    "position": 2,
	                    "name": "3. La ligne de commande et les entrées / sorties"
	                }
	            ]
	        },
	        {
	            "@type": "Article",
	            "@id": "https://thomas-veillard.fr/theorie-des-systemes-dexploitation-et-pratique-de-gnu-linux/chapitre-2-les-interfaces-utilisateur/3-la-ligne-de-commande-et-les-entrees-sorties/#article",
	            "isPartOf": {
	                "@id": "https://thomas-veillard.fr/theorie-des-systemes-dexploitation-et-pratique-de-gnu-linux/chapitre-2-les-interfaces-utilisateur/3-la-ligne-de-commande-et-les-entrees-sorties/#webpage"
	            },
	            "author": {
	                "@id": "https://thomas-veillard.fr/#/schema/person/98465ef1c45a4646324ef7c336388ffb"
	            },
	            "headline": "3. La ligne de commande et les entrées / sorties",
	            "datePublished": "2021-02-12T18:30:05+00:00",
	            "dateModified": "2021-02-14T12:46:07+00:00",
	            "mainEntityOfPage": {
	                "@id": "https://thomas-veillard.fr/theorie-des-systemes-dexploitation-et-pratique-de-gnu-linux/chapitre-2-les-interfaces-utilisateur/3-la-ligne-de-commande-et-les-entrees-sorties/#webpage"
	            },
	            "wordCount": 1379,
	            "publisher": {
	                "@id": "https://thomas-veillard.fr/#/schema/person/98465ef1c45a4646324ef7c336388ffb"
	            },
	            "image": {
	                "@id": "https://thomas-veillard.fr/theorie-des-systemes-dexploitation-et-pratique-de-gnu-linux/chapitre-2-les-interfaces-utilisateur/3-la-ligne-de-commande-et-les-entrees-sorties/#primaryimage"
	            },
	            "thumbnailUrl": "https://thomas-veillard.fr/wp-content/uploads/2021/01/ls-lhsa-etc.png",
	            "articleSection": [
	                "Chapitre 2. Les interfaces utilisateur",
	                "Théorie des systèmes d’exploitation et pratique de GNU/Linux"
	            ],
	            "inLanguage": "fr-FR"
	        },
	        {
	            "@type": [
	                "Person",
	                "Organization"
	            ],
	            "@id": "https://thomas-veillard.fr/#/schema/person/98465ef1c45a4646324ef7c336388ffb",
	            "name": "Thomas Veillard",
	            "image": {
	                "@type": "ImageObject",
	                "@id": "https://thomas-veillard.fr/#personlogo",
	                "inLanguage": "fr-FR",
	                "url": "http://2.gravatar.com/avatar/2008ad33ccb3924190bb884024ca6114?s=96&d=mm&r=g",
	                "contentUrl": "http://2.gravatar.com/avatar/2008ad33ccb3924190bb884024ca6114?s=96&d=mm&r=g",
	                "caption": "Thomas Veillard"
	            },
	            "logo": {
	                "@id": "https://thomas-veillard.fr/#personlogo"
	            },
	            "sameAs": [
	                "https://thomas-veillard.fr:8080"
	            ]
	        }
	    ]
	}</script>
	<!-- / Yoast SEO plugin. -->


<link rel="dns-prefetch" href="//fonts.googleapis.com">
<link href="https://fonts.gstatic.com/" crossorigin rel="preconnect">
<link rel="alternate" type="application/rss+xml" title="Thomas VEILLARD &raquo; Flux" href="https://thomas-veillard.fr/feed/">
<link rel="alternate" type="application/rss+xml" title="Thomas VEILLARD &raquo; Flux des commentaires" href="https://thomas-veillard.fr/comments/feed/">
<link rel="stylesheet" id="wp-block-library-css" href="https://thomas-veillard.fr/wp-includes/css/dist/block-library/style.min.css?ver=5.7.3" media="all">
<link rel="stylesheet" id="wp-block-library-theme-css" href="https://thomas-veillard.fr/wp-includes/css/dist/block-library/theme.min.css?ver=5.7.3" media="all">
<link rel="stylesheet" id="dashicons-css" href="https://thomas-veillard.fr/wp-includes/css/dashicons.min.css?ver=5.7.3" media="all">
<link rel="stylesheet" id="vlp-public-css" href="https://thomas-veillard.fr/wp-content/plugins/visual-link-preview/dist/public.css?ver=2.2.1" media="all">
<link rel="stylesheet" id="twentyfifteen-fonts-css" href="https://fonts.googleapis.com/css?family=Noto+Sans%3A400italic%2C700italic%2C400%2C700%7CNoto+Serif%3A400italic%2C700italic%2C400%2C700%7CInconsolata%3A400%2C700&#038;subset=latin%2Clatin-ext&#038;display=fallback" media="all">
<link rel="stylesheet" id="genericons-css" href="https://thomas-veillard.fr/wp-content/themes/twentyfifteen/genericons/genericons.css?ver=20201208" media="all">
<link rel="stylesheet" id="twentyfifteen-style-css" href="https://thomas-veillard.fr/wp-content/themes/twentyfifteen/style.css?ver=20201208" media="all">
<link rel="stylesheet" id="twentyfifteen-block-style-css" href="https://thomas-veillard.fr/wp-content/themes/twentyfifteen/css/blocks.css?ver=20190102" media="all">
<!--[if lt IE 9]>
<link rel='stylesheet' id='twentyfifteen-ie-css'  href='https://thomas-veillard.fr/wp-content/themes/twentyfifteen/css/ie.css?ver=20170916' media='all' />
<![endif]-->
<!--[if lt IE 8]>
<link rel='stylesheet' id='twentyfifteen-ie7-css'  href='https://thomas-veillard.fr/wp-content/themes/twentyfifteen/css/ie7.css?ver=20141210' media='all' />
<![endif]-->
<script src="https://thomas-veillard.fr/wp-includes/js/jquery/jquery.min.js?ver=3.5.1" id="jquery-core-js"></script>
<script src="https://thomas-veillard.fr/wp-includes/js/jquery/jquery-migrate.min.js?ver=3.3.2" id="jquery-migrate-js"></script>
<link rel="https://api.w.org/" href="https://thomas-veillard.fr/wp-json/">
<link rel="alternate" type="application/json" href="https://thomas-veillard.fr/wp-json/wp/v2/posts/696">
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="https://thomas-veillard.fr/xmlrpc.php?rsd">
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="https://thomas-veillard.fr/wp-includes/wlwmanifest.xml"> 
<meta name="generator" content="WordPress 5.7.3">
<link rel="shortlink" href="https://thomas-veillard.fr/?p=696">
<link rel="alternate" type="application/json+oembed" href="https://thomas-veillard.fr/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhttps://thomas-veillard.fr%2Ftheorie-des-systemes-dexploitation-et-pratique-de-gnu-linux%2Fchapitre-2-les-interfaces-utilisateur%2F3-la-ligne-de-commande-et-les-entrees-sorties%2F">
<link rel="alternate" type="text/xml+oembed" href="https://thomas-veillard.fr/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fhttps://thomas-veillard.fr%2Ftheorie-des-systemes-dexploitation-et-pratique-de-gnu-linux%2Fchapitre-2-les-interfaces-utilisateur%2F3-la-ligne-de-commande-et-les-entrees-sorties%2F&#038;format=xml">
		<style id="wp-custom-css">.entry-title {
	font-size: 1.6em !important;
	text-align: left;
}

article {
	text-align: justify;
	font-size: 0.9em;
}

@media screen and (min-width: 59.6875em) {
	.site-header {
		padding: 0 1em;
	}

	.main-navigation {
		margin: 1em;
	}
}

.main-navigation .current-menu-item > a, .main-navigation .current-menu-ancestor > a {
	font-weight: unset;
	color: black;
}

.main-navigation a {
	color: #666;
}

.no-puce, .no-puce ul {
	list-style-type: none;
}

table {
	margin-bottom: 0;
}

figcaption {
	margin-bottom: 1em !important;
}

h4 {
	margin-top: 1em !important;
	font-size: 1.25em !important;
}

h5 {
	font-size: 1em !important;
	text-transform: none !important;
	margin-top: 1em !important;
}

.exercice {
  padding: 1em;
  border-radius: 3px;
  border: 1px solid #795548;
  background: #f7f7f7;
}

.question {
  padding: 1em;
  border-radius: 3px;
  border: 1px solid #ab47bc;
  background: #f3e5f5;
}

.video-container {
	position: relative;
	padding-bottom: 56.25%; /* 16:9 */
	height: 0;
	margin-bottom: 1em;
}
.video-container iframe {
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
}

.card {
  background: #fff;
  border-radius: 2px;
  padding: 2rem 1rem;
}

.card-1 {
  box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
  transition: all 0.3s cubic-bezier(.25,.8,.25,1);
}

.card-1-hoverable:hover {
  box-shadow: 0 14px 28px rgba(0,0,0,0.25), 0 10px 10px rgba(0,0,0,0.22);
}

.post-thumbnail {
	margin-bottom: 0;
}

.entry-header {
	color: rgba(51, 51, 51, 0.7);
	font-family: "Noto Sans", sans-serif;
	background-color: #f7f7f7;
	padding-top: 2em;
	padding-bottom: 2em;
	margin-bottom: 1em;
}

.entry-title {
	margin: 0;
	font-weight: normal;
}

.hentry {
	padding-top: 0 !important;
}

table {
	table-layout: auto;
}

.menu-fr > a:before,
.menu-en > a:before {
	content: '';
	display: inline-block;
	width: 1.3em;
	height: 1em;
	margin-right: 0.5em;
}

.menu-fr > a:before {
	background-image: url('https://thomas-veillard.fr/wp-content/uploads/2021/04/fr.svg');
}

.menu-en > a:before {
	background-image: url('https://thomas-veillard.fr/wp-content/uploads/2021/04/en.svg');
}

blockquote, cite {
	font-size: 1em !important;
}

.ui-accordion-header h4 {
	margin-top: 0 !important;
}</style>
		</head>

<body class="post-template-default single single-post postid-696 single-format-standard wp-embed-responsive">
<div id="page" class="hfeed site">
	<a class="skip-link screen-reader-text" href="#content">Aller au contenu</a>

	<div id="sidebar" class="sidebar">
		<header id="masthead" class="site-header" role="banner">
			<div class="site-branding">
										<p class="site-title"><a href="https://thomas-veillard.fr/" rel="home">Thomas VEILLARD</a></p>
												<p class="site-description">Mes cours et supports pédagogiques pour l&#039;enseignement de l&#039;ingénierie informatique.</p>
										<button class="secondary-toggle">Menu			</button>
</div>
<!-- .site-branding -->
		</header><!-- .site-header -->

			<div id="secondary" class="secondary">

					<nav id="site-navigation" class="main-navigation" role="navigation">
				<div class="menu-theorie-des-systemes-dexploitation-et-pratique-de-gnu-linux-container"><ul id="menu-theorie-des-systemes-dexploitation-et-pratique-de-gnu-linux" class="nav-menu">
<li id="menu-item-135" class="menu-fr menu-item menu-item-type-taxonomy menu-item-object-category current-post-ancestor current-menu-parent current-post-parent menu-item-has-children menu-item-135">
<a href="https://thomas-veillard.fr/category/theorie-des-systemes-dexploitation-et-pratique-de-gnu-linux/">Théorie des systèmes d’exploitation et pratique de GNU/Linux</a>
<ul class="sub-menu">
	<li id="menu-item-49" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-49"><a href="https://thomas-veillard.fr/category/theorie-des-systemes-dexploitation-et-pratique-de-gnu-linux/chapitre-1-introduction/">Chapitre 1. Introduction</a></li>
	<li id="menu-item-558" class="menu-item menu-item-type-taxonomy menu-item-object-category current-post-ancestor current-menu-parent current-post-parent menu-item-558"><a href="https://thomas-veillard.fr/category/theorie-des-systemes-dexploitation-et-pratique-de-gnu-linux/chapitre-2-les-interfaces-utilisateur/">Chapitre 2. Les interfaces utilisateur</a></li>
</ul>
</li>
<li id="menu-item-1097" class="menu-en menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children menu-item-1097">
<a href="https://thomas-veillard.fr/category/front-end-web-development/">Modern web development</a>
<ul class="sub-menu">
	<li id="menu-item-1366" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-1366"><a href="https://thomas-veillard.fr/category/front-end-web-development/introduction/">Introduction</a></li>
	<li id="menu-item-2642" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-2642"><a href="https://thomas-veillard.fr/category/front-end-web-development/languages/">Languages</a></li>
</ul>
</li>
</ul></div>			</nav><!-- .main-navigation -->
		
		
		
	</div>
<!-- .secondary -->

	</div>
<!-- .sidebar -->

	<div id="content" class="site-content">

	<div id="primary" class="content-area">
		<main id="main" class="site-main" role="main">

		
<article id="post-696" class="post-696 post type-post status-publish format-standard hentry category-chapitre-2-les-interfaces-utilisateur category-theorie-des-systemes-dexploitation-et-pratique-de-gnu-linux">
	
	
	<header class="entry-header">
		<h1 class="entry-title">La ligne de commande et les entrées / sorties</h1>	</header><!-- .entry-header -->

	<div class="entry-content">
		
<h4>Rappels</h4>



<p>Lors des précédentes séances, nous avons abordé :</p>



<ul>
<li>bash, un interpréteur de ligne de commande et un langage de script.</li>
<li>coreutils, un ensemble de programmes en lignes de commande du projet GNU.</li>
<li>apt, pour installer des logiciels, en ligne de commande à nouveau.</li>
</ul>



<h4>L&rsquo;interpréteur de ligne de commande</h4>



<p>Bash est l’interpréteur le plus populaire sur les systèmes Unix et Unix-like. Il est installé et utilisé par défaut sur GNU/Linux, MacOS, etc.</p>



<p>Pour simplifier, on peut décrire bash en mode interactif comme un environnement où l&rsquo;utilisateur pose une question (commande) et reçoit une réponse (message texte).</p>



<p>Plus précisément, quand l&rsquo;utilisateur exécute une commande :</p>



<ol>
<li>L&rsquo;utilisateur saisit une commande et appuie sur la touche « entrée ».</li>
<li>Bash analyse la commande, qui suit une syntaxe précise.</li>
<li>Bash lance le programme désigné avec des arguments.</li>
<li>Le programme s&rsquo;exécute, produit une réponse (notamment un texte) et quitte.</li>
<li>Bash affiche la réponse à l&rsquo;utilisateur, puis attend une nouvelle commande.</li>
</ol>



<figure class="wp-block-image size-large"><img loading="lazy" width="768" height="553" src="https://thomas-veillard.fr/wp-content/uploads/2021/01/ls-lhsa-etc.png" alt="" class="wp-image-698" srcset="https://thomas-veillard.fr/wp-content/uploads/2021/01/ls-lhsa-etc.png 768w, https://thomas-veillard.fr/wp-content/uploads/2021/01/ls-lhsa-etc-300x216.png 300w" sizes="(max-width: 768px) 100vw, 768px"><figcaption>Exécution de la commande « ls -lhsa /etc » et affichage de la réponse du programme « ls ». Ce logiciel permet de lister le contenu d&rsquo;un répertoire et d&rsquo;afficher des propriétés des fichiers (nom, taille, propriétaire, permissions&#8230;).</figcaption></figure>



<h4>Structure d’une commande basique</h4>



<p class="exercice">Considérons la commande suivante : <span style="color:#3d85c6" class="has-inline-color">ls</span> <span style="color:#741b47" class="has-inline-color">-lhsa</span> <span style="color:#bf9000" class="has-inline-color">/etc</span></p>



<p><strong><span style="color:#3d85c6" class="has-inline-color">Le nom de la commande.</span></strong> En règle générale, une commande est en réalité un programme. Grâce à son nom, bash le retrouve dans les répertoires standards. Par exemple, cette commande lancera le programme dont le binaire se situe à l’emplacement /bin/ls. Ce logiciel permet de lister le contenu d&rsquo;un répertoire et d&rsquo;afficher des propriétés des fichiers (nom, taille, propriétaire, permissions&#8230;).</p>



<p><strong><span style="color:#741b47" class="has-inline-color">Les options</span></strong> permettent de personnaliser le comportement. Pour ls, d’après le manuel:</p>


<pre class="wp-block-code" aria-describedby="shcb-language-1" data-shcb-language-name="Bash" data-shcb-language-slug="bash"><link rel="stylesheet" id="syntax-highlighting-code-block-css" href="https://thomas-veillard.fr/wp-content/plugins/syntax-highlighting-code-block/vendor/scrivo/highlight-php/styles/default.css?ver=1.3.1" media="all"><div><code class="hljs language-bash"><span class="hljs-comment"># extrait de "man ls", commande qui permet d'accéder à la documentation de "ls"</span>
-l	use a long listing format
-s	<span class="hljs-built_in">print</span> the allocated size of each file, <span class="hljs-keyword">in</span> blocks
-a	<span class="hljs-keyword">do</span> not ignore entries starting with .
-h 	with -l and -s, <span class="hljs-built_in">print</span> sizes like 1K 234M 2G etc.</code></div><small class="shcb-language" id="shcb-language-1"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">Bash</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">bash</span><span class="shcb-language__paren">)</span></small></pre>


<p><strong><span style="color:#bf9000" class="has-inline-color">Les arguments</span></strong> permettent généralement de spécifier la cible du traitement. Par exemple, ls attend optionnellement une liste de chemins de dossiers et de fichiers à examiner.</p>



<h4>Les entrées d&rsquo;un processus</h4>



<p>Un processus accepte des <strong>entrées</strong> (qui contiennent un problème à résoudre). Il effectue ensuite des traitements, qui aboutissent à un résultat. Ce résultat étant communiqué, il s&rsquo;agit d&rsquo;une <strong>sortie</strong>. Enfin, le traitement peut échouer, auquel cas le processus remonte l&rsquo;erreur. C&rsquo;est aussi une <strong>sortie</strong>, bien qu&rsquo;on s&rsquo;en serait passé 😱 !</p>



<p class="exercice">Reprenons notre précédente commande : <span style="color:#3d85c6" class="has-inline-color">ls</span><span class="has-inline-color has-purple-color"> </span><span class="has-inline-color has-medium-pink-color">-lhsa /etc</span></p>



<p>Cette commande aboutit à lancer un processus <code>ls</code>. Ce processus a diverses entrées :</p>



<ul><li>Le contenu passé sur la ligne de commande après le nom du programme sera transmis au processus lors de son initialisation. Ainsi, l&rsquo;expression « <span class="has-inline-color has-medium-pink-color">-lhsa /etc</span> » a du sens pour le programme <code>ls</code> et formalise le problème à résoudre (cf. section précédente). On appelle ces contenus des « paramètres » et il s&rsquo;agit d&rsquo;une entrée pour le processus. À noter que cette entrée est immuable pour toute la vie du processus.</li></ul>



<ul><li>Diverses informations contextuelles. Par exemple, le processus connait le chemin du répertoire courant (répertoire depuis lequel l&rsquo;utilisateur a lancé le processus). Il connait aussi l&rsquo;identité de l&rsquo;utilisateur, etc. </li></ul>



<ul><li>D&rsquo;autres données peuvent arriver durant le cycle de vie du programme. Par exemple, un processus peut poser une question et laisser l&rsquo;utilisateur y répondre. Le processus reçoit chaque caractère saisi dans un flux. Ce flux venant du clavier s&rsquo;appelle l&rsquo;entrée standard.</li></ul>



<ul><li>Bien sûr, d&rsquo;autres flux d&rsquo;entrée peuvent être initiés par le processus : typiquement une connexion réseau ou une lecture de fichier.</li></ul>



<h4>Les sorties d&rsquo;un processus</h4>



<p>Toujours dans notre exemple <code>ls -lhsa /etc</code>, le résultat du processus est un texte. On regardera au passage que ce format autorise une mise en page en colonne ou un rendu de couleurs.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-2" data-shcb-language-name="Shell Session" data-shcb-language-slug="shell"><div><code class="hljs language-shell">thomas@thinkpad-laptop:~$ ls -lhsa /etc
total 1,3M
 12K drwxr-xr-x 156 root root    12K janv. 18 19:06 .
4,0K drwxr-xr-x  20 root root   4,0K mai   31  2020 ..
4,0K drwxr-xr-x   3 root root   4,0K avril 23  2020 acpi
4,0K -rw-r--r--   1 root root   3,0K avril 23  2020 adduser.conf
4,0K drwxr-xr-x   3 root root   4,0K avril 23  2020 alsa
 12K drwxr-xr-x   2 root root    12K janv. 18 19:12 alternatives
4,0K -rw-r--r--   1 root root    401 juil. 16  2019 anacrontab
4,0K -rw-r--r--   1 root root    244 oct.   7 10:42 antidote.conf
4,0K drwxr-xr-x   3 root root   4,0K oct.  23 10:19 apache2
4,0K -rw-r--r--   1 root root    433 oct.   2  2017 apg.conf
[...] sortie tronquée</code></div><small class="shcb-language" id="shcb-language-2"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">Shell Session</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">shell</span><span class="shcb-language__paren">)</span></small></pre>


<p>D&rsquo;ailleurs, la sortie console d&rsquo;un processus est un flux. La commande <code>ls</code> laisse penser qu&rsquo;il faut attendre la complétion de l&rsquo;exécution du programme pour avoir le résultat. C&rsquo;est faux, et une commande que <code>htop</code> le démontre. Un processus peut envoyer des messages par intermittence.</p>



<figure class="wp-block-image size-large"><img loading="lazy" width="734" height="524" src="https://thomas-veillard.fr/wp-content/uploads/2021/01/htop-actualise-sa-sortie-par-intermittence.gif" alt="" class="wp-image-863"><figcaption>htop, un gestionnaire de tâches en ligne de commande, actualise son contenu par intermittence. Il prouve aussi qu&rsquo;un programme sans interface graphique peut utiliser des mises en formes évoluées et des couleurs. </figcaption></figure>



<p>D&rsquo;autres productions de sorties auraient été envisageables : écriture d&rsquo;un fichier sur le disque, envoi d&rsquo;un message sur une connexion, etc.</p>



<h4>Les flux standards d&rsquo;entrée/sortie</h4>



<p>Sous Linux en particulier, les programmes en lignes de commande ont recours à 3 flux standards. Ils permettent au processus de communiquer avec l&rsquo;utilisateur ou d&rsquo;autres processus.</p>



<ul><li>Le flux d&rsquo;<strong>entrée standard</strong>, nommé <strong>STDIN</strong> et indexé comme le flux numéro 0. Par exemple, quand bash est en attente d&rsquo;une commande, chaque caractère saisi par l&rsquo;utilisateur est envoyé à bash via son flux d&rsquo;entrée.</li></ul>



<ul><li>Le flux de <strong>sortie standard</strong> (<strong>STDOUT</strong>, n°1). Un processus peut utiliser ce flux pour afficher une réponse à l&rsquo;utilisateur. Par exemple, <code>ls</code> affiche la liste des répertoires sous la forme d&rsquo;un texte. Vous avez aussi rencontré <code>htop</code>, qui écrit à intervalle de temps réguliers dans ce flux.</li></ul>



<ul><li>Le flux de <strong>sortie d&rsquo;erreur standard </strong>(<strong>STDERR</strong>, n°2). De la même manière que le processus envoie un résultat valide sur STDOUT, il peut envoyer un message d&rsquo;erreur sur STDERR. <code>ls</code> utilise par exemple ce flux s&rsquo;il ne parvient pas à ouvrir un répertoire. Il s&rsquo;agit dans les 2 cas d&rsquo;un résultat produit par le processus, mais les différencier par le canal permet de les traiter séparément (notamment dans des scripts).</li></ul>



<figure class="wp-block-image size-large"><img loading="lazy" width="1024" height="605" src="https://thomas-veillard.fr/wp-content/uploads/2021/01/Stdstreams-notitle.svg-1024x605.png" alt="" class="wp-image-847" srcset="https://thomas-veillard.fr/wp-content/uploads/2021/01/Stdstreams-notitle.svg-1024x605.png 1024w, https://thomas-veillard.fr/wp-content/uploads/2021/01/Stdstreams-notitle.svg-300x177.png 300w, https://thomas-veillard.fr/wp-content/uploads/2021/01/Stdstreams-notitle.svg-768x454.png 768w, https://thomas-veillard.fr/wp-content/uploads/2021/01/Stdstreams-notitle.svg-1536x908.png 1536w, https://thomas-veillard.fr/wp-content/uploads/2021/01/Stdstreams-notitle.svg.png 1920w" sizes="(max-width: 1024px) 100vw, 1024px"><figcaption>Les flux standard sous Linux : entrée, sortie, erreur. Source <a href="https://fr.wikipedia.org/wiki/Flux_standard" target="_blank" rel="noreferrer noopener">Wikipédia</a></figcaption></figure>



<p>Cette façon de gérer les flux standard sous Linux fait partie de la norme POSIX.</p>



<h4>Redirection du flux vers un fichier</h4>



<p>Vous avez ci-dessous une démonstration de redirection de flux.</p>



<figure class="wp-block-image size-full"><img loading="lazy" width="1125" height="697" src="https://thomas-veillard.fr/wp-content/uploads/2021/01/demo-redirection-de-flux.gif" alt="" class="wp-image-868"><figcaption>Démonstration d&rsquo;une redirection de flux vers un fichier.</figcaption></figure>



<ol>
<li>D&rsquo;abord, je saisis la commande <code>ls -lhsa</code>. La sortie est affichée en console. Un seul fichier <code>fichier.txt</code> existe dans le répertoire courant. Un explorateur graphique de fichiers est ouvert en arrière-plan dans le même répertoire.</li>
<li>Ensuite, j&rsquo;adapte cette commande pour rediriger la sortie vers un fichier. Cette commande adaptée est <code>ls -lhsa &gt; sortie_redirigee.txt</code>.</li>
<li>Aucune sortie n&rsquo;est affichée en console. Un fichier est créé dans le répertoire courant. Je l&rsquo;ouvre et on y retrouve le contenu de notre première commande.</li>
</ol>



<p>Dans cette démonstration, nous avons seulement redirigé le flux STDOUT vers le fichier. On peut faire bien plus avec les redirections.</p>



<h4>Redirection de STDOUT et STDERR en détails</h4>



<p>Ces deux exemples sont équivalents. Ils redirigent STDOUT (flux n°1) vers un fichier. En cas d&rsquo;erreur sur STDERR, les messages s&rsquo;affichent toujours en console.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-3" data-shcb-language-name="Bash" data-shcb-language-slug="bash"><div><code class="hljs language-bash">ls -lhsa &gt; sortie_redirigee.txt
ls -lhsa 1&gt; sortie_redirigee.txt</code></div><small class="shcb-language" id="shcb-language-3"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">Bash</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">bash</span><span class="shcb-language__paren">)</span></small></pre>


<p>Il est aussi possible de rediriger le flux STDERR (flux n°2) avec cette syntaxe.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-4" data-shcb-language-name="Bash" data-shcb-language-slug="bash"><div><code class="hljs language-bash">ls -lhsa 2&gt; sortie_erreur_redirigee.txt</code></div><small class="shcb-language" id="shcb-language-4"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">Bash</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">bash</span><span class="shcb-language__paren">)</span></small></pre>


<p>On peut rediriger séparément STDOUT et STDERR vers deux fichiers différents.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-5" data-shcb-language-name="Bash" data-shcb-language-slug="bash"><div><code class="hljs language-bash">ls -lhsa 1&gt; sortie_redirigee.txt 2&gt; sortie_erreur_redirigee.txt</code></div><small class="shcb-language" id="shcb-language-5"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">Bash</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">bash</span><span class="shcb-language__paren">)</span></small></pre>


<p>Une syntaxe permet de rediriger STDERR vers STDOUT. Dans le cas présent, STDOUT restant affiché en console, toute la sortie du programme est en console.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-6" data-shcb-language-name="Bash" data-shcb-language-slug="bash"><div><code class="hljs language-bash">ls -lhsa 2&amp;&gt;1</code></div><small class="shcb-language" id="shcb-language-6"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">Bash</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">bash</span><span class="shcb-language__paren">)</span></small></pre>


<p>On peut chaîner la redirection STDERR vers STDOUT, puis STDOUT vers un fichier.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-7" data-shcb-language-name="Bash" data-shcb-language-slug="bash"><div><code class="hljs language-bash">ls -lhsa 2&amp;&gt;1 &gt; sortie_fusionnee_redirigee.txt</code></div><small class="shcb-language" id="shcb-language-7"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">Bash</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">bash</span><span class="shcb-language__paren">)</span></small></pre>


<p>Les redirections avec un simple &lsquo;>&rsquo; détruisent le fichier existant. À l&rsquo;inverse, la syntaxe avec deux chevrons permet d&rsquo;ajouter le contenu en fin de fichier.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-8" data-shcb-language-name="Bash" data-shcb-language-slug="bash"><div><code class="hljs language-bash">ls -lhsa &gt;&gt; sortie_redirigee.txt</code></div><small class="shcb-language" id="shcb-language-8"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">Bash</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">bash</span><span class="shcb-language__paren">)</span></small></pre>


<h4>Envoyer un fichier vers STDIN</h4>



<p>S&rsquo;il est possible de rediriger les flux de sortie STDOUT et STDERR vers un fichier, attendez-vous à ce que rediriger un fichier vers STDIN le soit aussi 😋.</p>



<p>Seul le sens du chevron change. Ainsi, la commande <code>wc -l &lt; fichier.txt</code> lance la commande <code>cat</code> et lui passe le contenu de <code>fichier.txt</code> en entrée (sur STDIN).</p>



<p>La commande <code>wc -l</code> compte le nombre de lignes lues depuis l&rsquo;entrée standard jusqu&rsquo;à ce que le flux soit fermé. Elle me servira à illustrer la redirection d&rsquo;un flux du fichier vers le STDIN d&rsquo;un processus.</p>



<figure class="wp-block-image size-large"><img loading="lazy" width="739" height="519" src="https://thomas-veillard.fr/wp-content/uploads/2021/02/Demo-wc.gif" alt="" class="wp-image-1774"><figcaption>Démonstration de wc -l qui compte le nombre de lignes envoyées sur STDIN. La combinaison Ctrl + D met fin à la lecture et affiche « 6 ».</figcaption></figure>



<p>Maintenant que le comportement de <code>wc -l</code> est clair, voyons comment lui passer le contenu de <code>fichier.txt</code> en entrée, ce sorte qu&rsquo;il en compte le nombre de lignes.</p>



<figure class="wp-block-image size-large"><img loading="lazy" width="739" height="519" src="https://thomas-veillard.fr/wp-content/uploads/2021/02/Demo-wc-avec-redirection-de-flux.gif" alt="" class="wp-image-1775"></figure>



<ol>
<li>Tout d&rsquo;abord, je crée un nouveau fichier sobrement nommé <code>fichier.txt</code>. Il contient l&rsquo;introduction de cette séance.</li>
<li>Ensuite, je lance <code>wc -l</code> en redirigeant le contenu du fichier vers STDIN. Et le tour est joué. Simple, n&rsquo;est-ce pas ?</li>
</ol>
<style class="advgb-styles-renderer">.wp-block-code {
	border: 0;
	padding: 0;
}

.wp-block-code > div {
	overflow: auto;
}

.shcb-language {
	border: 0;
	clip: rect(1px, 1px, 1px, 1px);
	-webkit-clip-path: inset(50%);
	clip-path: inset(50%);
	height: 1px;
	margin: -1px;
	overflow: hidden;
	padding: 0;
	position: absolute;
	width: 1px;
	word-wrap: normal;
	word-break: normal;
}

.hljs {
	box-sizing: border-box;
}

.hljs.shcb-code-table {
	display: table;
	width: 100%;
}

.hljs.shcb-code-table > .shcb-loc {
	color: inherit;
	display: table-row;
	width: 100%;
}

.hljs.shcb-code-table .shcb-loc > span {
	display: table-cell;
}

.wp-block-code code.hljs:not(.shcb-wrap-lines) {
	white-space: pre;
}

.wp-block-code code.hljs.shcb-wrap-lines {
	white-space: pre-wrap;
}

.hljs.shcb-line-numbers {
	border-spacing: 0;
	counter-reset: line;
}

.hljs.shcb-line-numbers > .shcb-loc {
	counter-increment: line;
}

.hljs.shcb-line-numbers .shcb-loc > span {
	padding-left: 0.75em;
}

.hljs.shcb-line-numbers .shcb-loc::before {
	border-right: 1px solid #ddd;
	content: counter(line);
	display: table-cell;
	padding: 0 0.75em;
	text-align: right;
	-webkit-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
	user-select: none;
	white-space: nowrap;
	width: 1%;
}</style>	</div>
<!-- .entry-content -->

	
	
	<footer class="entry-footer">
		<span class="cat-links"><span class="screen-reader-text">Catégories </span><a href="https://thomas-veillard.fr/category/theorie-des-systemes-dexploitation-et-pratique-de-gnu-linux/chapitre-2-les-interfaces-utilisateur/" rel="category tag">Chapitre 2. Les interfaces utilisateur</a>, <a href="https://thomas-veillard.fr/category/theorie-des-systemes-dexploitation-et-pratique-de-gnu-linux/" rel="category tag">Théorie des systèmes d’exploitation et pratique de GNU/Linux</a></span>			</footer><!-- .entry-footer -->

</article><!-- #post-696 -->


	<nav class="navigation post-navigation" role="navigation" aria-label="Publications">
		<h2 class="screen-reader-text">Navigation de l’article</h2>
		<div class="nav-links"><div class="nav-previous"><a href="https://thomas-veillard.fr/theorie-des-systemes-dexploitation-et-pratique-de-gnu-linux/chapitre-2-les-interfaces-utilisateur/2-utiliser-les-instantanes-de-vm-et-changer-denvironnement-de-bureau-tp/" rel="prev"><span class="meta-nav" aria-hidden="true">Précédent</span> <span class="screen-reader-text">Article précédent&nbsp;:</span> <span class="post-title">2. Instantanés de VM et changement d&rsquo;environnement de bureau (TP)</span></a></div></div>
	</nav>
		</main><!-- .site-main -->
	</div>
<!-- .content-area -->


	</div>
<!-- .site-content -->

</div>
<!-- .site -->

<script src="https://kit.fontawesome.com/f02a77f3db.js" crossorigin="anonymous"></script>
<script src="https://thomas-veillard.fr/wp-content/plugins/thomas/js/main.js"></script>
<script data-ad-client="ca-pub-9505048372269906" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NH45PR7ELJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NH45PR7ELJ');
</script>
<script src="https://thomas-veillard.fr/wp-content/themes/twentyfifteen/js/skip-link-focus-fix.js?ver=20141028" id="twentyfifteen-skip-link-focus-fix-js"></script>
<script id="twentyfifteen-script-js-extra">
var screenReaderText = {"expand":"<span class=\"screen-reader-text\">ouvrir le sous-menu<\/span>","collapse":"<span class=\"screen-reader-text\">fermer le sous-menu<\/span>"};
</script>
<script src="https://thomas-veillard.fr/wp-content/themes/twentyfifteen/js/functions.js?ver=20171218" id="twentyfifteen-script-js"></script>
<script src="https://thomas-veillard.fr/wp-includes/js/wp-embed.min.js?ver=5.7.3" id="wp-embed-js"></script>

</body>
</html>